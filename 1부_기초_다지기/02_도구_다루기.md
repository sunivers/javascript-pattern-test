# 테스팅 프레임워크
이 책에서는 jasmine 테스팅 프레임워크를 사용한다.

## 잘못된 코드 발견하기
TDD를 실천하면 코드 결함을 최대한 빨리 발견한다. 그래서 작은 기능 하나라도 테스트를 먼저 작성한 뒤, 최소한의 코드만으로 기능을 구현한다.

## 테스트성을 감안하여 설계하기
어떤 코드의 테스트 용이성과 그 코드의 테스트가 잘 이루어졌는지는 상관 관계가 있다. 또한 테스트하기 쉬운 코드가 유지 보수성과 확장성이 월등히 우수하다.  
1장에서 나온 SOLID 개발 원칙을 준수하면 테스트에 많이 도움이 된다. 코드의 테스트성(testability)을 우선시 하여 개발해야 한다.  

만약 기존 함수에 api를 호출하는 코드를 추가해야 하는 상황이 왔을 때, 이 코드 하나로 인해 단위 테스트 하기가 힘들어지게 된다. 여기서 과연 기존의 함수가 api 호출까지 맡아야 하는지에 대한 의문이 생기게 된다.  
이 지점이 바로 코드의 테스트성을 극대화 하면서 자연스럽게 SOLID 원칙을 어긴 코드를 솎아내게 되는 부분이다.

## 꼭 필요한 코드만 작성하기
실패하는 테스트를 먼저 작성한 뒤, 테스트를 성공시킬 만큼만 최소한으로 코딩한다. 이 후 세부적으로 리팩토링하여 중복 코드를 들어낸다.

이것이 바로 그 TDD 방법론을 이야기 할 때 항상 나오는 red-green-refactor 와 같은 맥락인 것 같다.
![image](https://user-images.githubusercontent.com/26291081/99900102-4289ce00-2cf1-11eb-8667-e17f7f78b667.png)

## 안전한 유지 보수와 리팩토링
예전에 잘 돌아가던 코드가 지금은 잘 동작하지 않는 `회귀 결함`은 코드 품질과 신뢰를 떨어트린는 요인이다.
TDD가 당장은 짐만 되고 개발/보수 비용만 가중되는 일처럼 보이지만, 나중에 언젠가 큰 변경이 필요할 때 테스트 코드로 인해 보험금을 타는 느낌(안도감)을 느낄 것이다.

## 실행 가능한 명세
잘 구축된 테스트 꾸러미는 `실행 가능한 명세` 역할도 한다. 특히 단위 테스트를 행위 기반(behavior-based)으로 구성하면 검증할 각각의 로직을 일상 문장으로 표현하기 때문에 일종의 `명세` 역할을 하게 되는 것이다.
이것은 협업하는 다른 개발자나 먼 훗날 미래의 자신에게도 도움이 된다.

## 재스민 들어가기
재스민은 행위 주도 개발(BDD) 방식으로 자바스크립트 단위 테스트를 위한 라이브러리다.

### 테스트 꾸러미와 스펙
- descibe : 테스트 꾸러미의 구현부
- it : 적어도 한 개의 기대식을 가진 함수
- beforeEach/afterEach : 각 테스트 꾸러미가 실행되기 전/후에 호출되는 함수. 전체 테스트에 공유되는 설정 및 데이터를 넣어두어 중복 코드를 피할 수 있다.
- beforEach 함수를 이용해 DRY 원칙에 맞게 리팩토링한 코드.
```
describe('createReservation(passenger, flight)', function () {

  var testPassenger = null,
    testFlight = null,
    testReservation = null;

  beforeEach(function () {
    testPassenger = {
      firstName: '소영',
      lastName: '박'
    }
    testFlight = {
      number: '3443',
      carrier: '대한항공',
      destination: '울산'
    }
    testReservation = createReservation(testPassenger, testFlight);
  })

  it('주어진 passenger를 passengerInfo 프로퍼티에 할당한다', function () {
    expect(testReservation.passengerInformation).toBe(testPassenger);
  });

  it('주어진 flight를 flightInfo 프로퍼티에 할당한다', function () {
    expect(testReservation.flightInformation).toBe(testFlight);
  });
});
```

### 기대식과 매처
기대식은 모든 테스트마다 있다. `expect` 함수가 기대식인데, 테스트 코드가 낸 실제값을 인자로 받아 매처를 통해 기댓값과 비교한다.  
매처란? 실제값과 기대값을 비교하는 일을 한다. 위 코드에서는 `toBe`가 매처다.  
매처는 성공여부에 따라 true, false를 반환하고 하나 이상의 기대식이 포함된 스펙에서 매처가 하나라도 실패하면 모조리 실패하는것으로 간주한다.  
재스민은 내장 매처중에 용도에 맞는게 없다면 커스텀 매처를 만들어 쓸 수 있도록 지원한다.

### 스파이
재스민 스파이(spy)는 **테스트 더블** 역할을 하는 함수다.
> 테스트 더블이란? 아래 다섯 가지를 통칭하는 말이다.
> - 더미(dummy)
> - 틀(stub)
> - 스파이(spy)
> - 모의체(fake)
> - 모형(mock)

스파이는 단위 테스트를 웹 서비스나 DB 같은 외부 자원과의 의존 관계를 없애고 테스트의 복잡도를 낮추기 위해 사용된다.
외부 시스템과 연동하는 테스트는 **통합 테스트**로서 **단위 테스트**와는 분명히 구별되어야 한다.

재스민에서는 `spyOn` 이라는 함수가 있어서 특정 객체의 특정 함수가 호출됐는지 여부를 판단할 수 있다.
```
spyOn('특정 객체', '특정 객체의 메소드');
// ... 해당 메소드를 이용하는 함수 실행
expect('특정 객체의 메소드').toHaveBeenCalled();
```


# 의존성 주입 프레임워크
의존성 **역전**이 5대 SOLID 개발 요소 중 하나고, 의존성 **주입**은 이를 실현하기 위한 매커니즘.

## 의존성 주입이란?
여러 모듈을 가져와서 사용할 때, 객체가 해당 모듈에 의존해서는 안된다. 단위 테스트가 가능하게 하려면 의존성을 주입하는 형태가 되어야 한다.
```
Attendee = function() {
  // http 통신하는 모듈.
  this.service = new WebSvc();
}
Attendee.prototype.reserve = function() {
  if (this.service.reserve()) {
    // 호출 이후 처리...
  }
}
```
위에 http 통신 모듈에 의존하는 코드는 단위 테스트를 작성할 수가 없다. 아래처럼 의존성을 주입하도록 변경해야 한다.
```
Attendee = function(serviceInstance) {
  // http 통신하는 모듈.
  this.service = serviceInstance;
}

// 운영 환경
var attendee = new Attendee(new WebSvc());

// 테스트 환경
var attendee = new Attendee(fakeService);
```
이렇게 하면 테스트 시에 재스민 스파이 같은 대체제를 주입할 수 있다.


## 의존성을 주입하여 믿음직한 코드 만들기
의존성 주입(DI)은 실제 객체보다 주입한 스파이나 모의 객체에 더 많은 제어권을 부여하므로 다양한 엣지 케이스를 만들어 내기가 쉽다.  
그래서 만약의 사태를 폭넓게 커버하는 테스트를 작성할 수 있다.

## 의존성 주입의 모든 것
아래 질문 중 한 가지라도 답변이 "예"가 나온다면 직접 인스턴스화 하지 말고 주입하는 방향으로 전환하자.
1. 객체 또는 의존성 중 어느 하나라도 DB, 설정 파일, HTTP, 기타 인프라 등 외부 자원에 의존하는가?
2. 객체 내부에서 발생할지 모를 에러를 테스트에서 고려해야 하나?
3. 특정한 방향으로 객체를 작동시켜야 할 테스트가 있는가?
4. 서드파티 제공 객체가 아니라 온전히 내가 소유한 객체인가?

# 애스팩트 툴킷

## 애스팩트 지향 프로그래밍(AOP)이란?
기존에 비즈니스 관점에서 객체를 만들던 OOP와는 다르게 부가기능 관점에서 관심사의 분리(모듈화)를 허용하는 것이다.  
쉽게 말하면 OOP 모듈들을 옆에서 바라보았을 때 중복되는 로직(부가기능)들이 있는데 그것들을 묶어서 관리할 수 있게 해준다는 것이다. 자세한 설명은 [여기](https://jojoldu.tistory.com/71)를 보고 참고했다.  

### AOP 용어
- **어드바이스** : 실질적인 코드 조각으로 애스팩트가 '무엇'을 '언제'할지 정의한다.
- **애스팩트** : 객체지향 모듈을 오브젝트라 부르는것과 같이 부가기능 모듈을 애스펙트라 부르며 어드바이스가 처리할 문제를 뜻한다. 횡단 관심사(cross-cutting)라고도 한다.

## 사례 연구: AOP 있는/없는 캐싱
기존 코드에 캐싱기능을 추가한다고 할 때, AOP 없이 구현한다면 해당 함수에 핵심기능과 무관한 코드가 추가될 뿐더러 테스트 코드도 새로 다시 짜야 한다.  
기존 코드를 그대로 둔 상태에서 기능만 추가할 수 있게 해주는 것이 바로 애스팩트 지향 프로그래밍!  
AOP 프레임워크를 사용하면 원본 코드를 건드리지 않고 애플리케이션 시동 로직에 코드를 넣을 수 있다.

### AOP로 믿음직한 코드 만들기
AOP가 믿음직한 코드를 만드는 방법.
1. AOP는 함수를 단순하게 유지한다. 함수 각자 단일 책임을 수행할 뿐이다.
2. AOP는 코드를 DRY하게 해준다. 애초에 반복되는 코드를 묶어 모듈화 하는 것이 목적이기 때문에 당연한 얘기다.
3. AOP는 애플리케이션 설정을 한 곳에 집중시킨다. 애스팩트 설정이 단일 책임인 함수가 하나만 있으면 나중에 부가 기능 전체를 찾을 때 이 함수 하나만 뒤지면 된다. 디버깅시에도 손쉽게 해당 기능을 끄고 켤 수 있다.

## 결론
자바스크립트 AOP는 구현하기 쉽고, 업데이트할 일이 거의 없는 최소한의 필수 기능만 구현된 라이브러리들이 있다. 프레드락 아펠버그와 데이브 클레이턴이 만든 `Aop.js`가 대표적이다. 50줄 밖에 안되는 코드로 많은 일을 할 수 있다니 써봄직 하다.

# 코드 검사 도구
코드를 실행하지 않은 상태에서 소스 코드의 구조와 구문을 조사하는 정적 분석 도구를 린터(linter)라고 한다. 에러가 날 수 있는 부분이나 프로그래밍 언어를 부정확하게 사용한 곳을 실행 전에 미리 알려준다.

## 린팅 도구로 믿음직한 코드 만들기
다음은 마일리지를 계산하는 함수의 구현부다. 이상한 부분이 없는지 찾아보자.
```
var nums = [1, 2, 3];
var result = [];
for (var i = 0; i < 3; i++) {
  var calc = function(num) {
    return num * 3;
  }
  result[i] = calc(nums[i])
}
```
반복문 안에서 함수를 계속 선언한다. 이 코드는 실행시에 문제없이 실행되지만 분명 비효율적이고 비정상적인 코드다. 테스트 코드로도 잡아낼 수 없는 이 문제는 린터가 잡아줄 수 있다.

## 도구들
- JSHint
- JSLint
- ESLint

## 엄격모드
ES5 명세에서 처음 도입된 자바스크립트 설정인 `use strict`를 사용하면 해당 스코프는 일반 자바스크립트와는 다르게 해석된다.  
주로 개발자가 흔히 저지르는 실수를 범하면 에러를 뿜어낸다. (변수 선언 전 사용, 예약어로 변수명 사용, 읽기 전용 프로퍼티 수정 등)  

# 정리하기
올바른 소프트웨어 개발을 위해 단위 테스팅 프레임워크는 필수품이다.  
컴포넌트를 잘 정돈하고 분리하기 위해서 의존성 주입은 중요한 테크닉이다.  
애스팩트 지향 프로그래밍(AOP)를 쓰면 기존 코드를 유지한 채 공통 기능을 끼워 넣을 수 있고 코드를 DRY하게 유지할 수 있다.
린터를 통해 코드 믿음성을 높이고 실수를 예방하자.