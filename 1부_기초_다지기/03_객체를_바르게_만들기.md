# 원시형
자바스크립트 원시형은 6개다.
- 문자열 (String)
- 숫자 (Number)
- 불 (Boolean)
- null
- undefined
- 심볼 (Symbol) - ES6에서 추가됐다.

객체는 원시형에 속하지 않는다.
그러나 문자열로 선언한 변수에서 length 프로퍼티를 호출하면 에러 없이 잘 실행된다.
```
const str = 'abced';
console.log(str.length); // 실행 결과: 5
```
물론 당연히 원시형에는 프로퍼티가 없다. 위 코드가 잘 실행되는 이유는 자바스크립트 엔진이 코드를 보고 알아서 객체를 생성해주기 때문이다.  
위 코드에서는 String 객체를 만들어내고 이 객체의 length 프로퍼티 값을 참조한다. 이렇게 만들어진 String 객체는 바로 가비지 컬렉션(GC) 대상이 된다.

문자열, 불리언, 숫자 타입 모두 그들만의 객체 래퍼, String, Boolean, Number를 갖는다.  

한 번 이상 참조할 상수는 변수에 담아두고 변수를 대신 참조해야 코드를 DRY하게 유지하면서 특정 값을 사용하는 코드를 찾기 쉽다.

# 객체 리터럴
객체 리터럴은 아래와 같이 생성한 객체를 말한다.
```
{ name: 'soyoung', job: 'programmer', age: 20 }
```
객체 리터럴로 생성한 객체를 바로 변수에 넣거나 혹은 아래처럼 팩토리 함수를 만들어 항상 새로운 객체를 반환하도록 정의할 수 있다.
```
const getSoyoung = () => ({ name: 'soyoung', job: 'programmer', age: 20 });
const me = getSoyoung();
```
팩토리 함수로 생성하면 객체 리터럴을 바로 변수에 대입하는 방식보다 여러 가지 장점이 있다.

1. TDD 방식으로 개발할 때 함수의 경우 원하는 프로퍼티를 가진 객체를 반환하는지 확인이 가능하지만 객체 리터럴은 확인이 불가하다.
2. 함수로 만든 객체는 객체 리터럴 내에 선언된 함수 프로퍼티도 테스트가 가능하다. 
3. 팩토리 함수로 반환한 객체 리터럴을 after 애스팩트에 래핑이 가능해져 2장에서 언급한 AOP(애스팩트 지향 프로그래밍)이 가능하다.
4. 마찬가지로 의존성 주입도 가능하다.
5. 또한 단순 객체 리터럴은 생성시 검증이 불가능하다. 그래서 싱글톤이나 확실히 테스트를 마친 코드에서 생성된 객체 리터럴이 아닌 경우 쓰지 않는 편이 좋다.

객체 리터럴은 함수 인자가 많아서 순서를 맞추기 힘들 때 사용하면 좋다. ES6 문법 중 하나인 구조 분해 할당 문법과 같이 사용하면 정말 유용하다.

# 모듈 패턴
모듈 패턴은 자바스크립트에서 가장 명망 높은 패턴 중 하나다.

## 임의 모듈 생성
원하는 시점에 언제라도 생성할 수 있는 모듈. 모듈 함수를 호출하여 API를 얻는다.
```
const MyApp = {};

MyApp.wildLifeSimulator = function(animalMaker) {
  // 프라이빗 변수
  let animals = [];
  
  // API 반환
  return {
    addAnimal: function(species, sex) {
      animals.push(animalMaker.make(species, sex));
    },
    getAnimalCount: function() {
      return animals.length;
    }
  }
}
```

위 모듈은 객체 리터럴을 반환하고, animalMaker 같은 의존성을 주입하여 반환하는 리터럴에서 참조하게 만들었다.
이 모듈은 다른 모듈에도 주입 가능하여 1장에서 배운 개방/폐쇄 원칙에 가장 적합하다.

## 즉시 실행 모듈 생성
즉시 실행 모듈은 임의 모듈과 같지만, 함수를 선언하자마자 실행하는 방법이다. 반환된 API는 이름공간을 가진 전역 변수에 할당되어 해당 모듈의 **싱글톤 인스턴스**가 된다.
```
// 위 코드와 동일
MyApp.wildLifeSimulator = (function(animalMaker) {
  // ... (중략)
}()); // <- 즉시 실행한다.

// 싱글톤은 아래처럼 사용한다.
MyApp.wildLifeSimulator.addAnimal(...);
```

위 코드는 애플리케이션 실행과 상관없이 코드가 작성된 지점에서 즉시 실행된다. 따라서 함수 실행 당시에 의존성을 가져오지 못하면 주입할 수 없다.  
싱글톤이 꼭 필요하다면 `임의 모듈 패턴`으로 코딩하고 해당 모듈을 요청할 때마다 의존성 주입 프레임워크에서 같은 인스턴스를 제공하는 것이 낫다.

## 모듈 생성의 원칙
1. 단일 책임 원칙을 잊지 말고 한 모듈에 한 가지 일만 시키자.
2. 모듈 자신이 쓸 객체가 필요하다면 의존성 주입 형태로 제공하는 방안을 고려하자.
3. 다른 객체 로직을 확장하는 모듈은 해당 로직의 의도가 바뀌지 않도록 분명히 밝히자.(리스코프 치환 원칙(?))

# 객체 프로토타입과 프로토타입 상속
자바스크립트 객체는 생성 매커니즘과 무관하게 프로토타입 객체로 연결되어 프로퍼티를 상속한다.

## 기본 객체 프로토타입
객체 리터럴은 저절로 내장 객체 Object.prototype에 연결된다.
```
const developer = {
  hasFingers: true,
  typing() {
    return '개발자는 키보드를 칩니다.'
  }
}
```
developer.toString()을 호출하면 자바스크립트 엔진은 프로토타입을 거슬러 올라가서 Object.prototype에 정의된 toString 함수 프로퍼티를 발견하고 실행한다. 만약 developer 자체에 toString이 정의되어 있다면 프로토타입을 실행하지 않고 바로 developer에서 toString을 찾아 실행한다.

## 프로토타입 상속
프로토타입 상속은 기본 프로토타입을 맞춤형 프로토타입으로 대체할 때 그 진가가 드러난다. 위에 정의한 developer 객체와 함께 designer 객체가 있다고 한다면 둘 다 사람이기 때문에 공유하는 프로퍼티가 분명 있을 것이다. 
이러한 공유 프로퍼티를 객체에 담아두고 **공유 프로토타입**으로 두면 객체마다 프로퍼티를 반복할 필요가 없다.

Object.create 를 사용하면 기존 객체와 프로토타입이 연결된 새로운 객체를 만들 수 있다.
```
const person = {
  hasFingers: true,
  hasLegs: true,
  walk() {
    return '걷기'
  }
}
const developer = Object.create(person);
const designer = Object.create(person);
```

## 프로토타입 체인
프로토타입 체인이라는 다층 프로토타입을 이용하면 여러 계층의 상속을 구현할 수 있다.  
앞서 상속에서 적용한 상속을 한 단계 더 적용하면 다층 상속이 가능해지는데, 너무 깊숙이 프로토타입 체인을 찾게 되면 성능상 좋을 것이 없다.

# new 객체 생성
C#, C++, 자바 등 고전 언어에서 사용되는 new 구문 패턴은 자바스크립트에서도 가능하다. 그러나 자바스크립트에서는 `new` 키워드와 함께 사용하려고 작성한 생성자 함수를 반드시 `new`와 함께 호출하도록 강요하지 않는다. 따라서 `new` 사용을 강제하도록 조치가 필요하다.

## instanceof
instanceof 연산자는 우변 피연산자의 프로토타입이 좌변 피연산자의 프로토타입 체인에 있는지 찾아본다. 있으면 좌변 피연산자는 우변 피연산자의 **인스턴스**라고 결론 내린다.   
> new 키워드를 붙여 생성자 함수를 실행하면 일단 빈 객체를 하나 만들고 그 객체의 프로토타입을 생성자 함수의 프로토타입 프로퍼티에 연결한다. 그 다음 생성자 함수를 this로 실행하여 새 객체를 찍어낸다.

다음과 같이 생성자 함수 내에서 new로 생성했는지 instanceof로 체크하면 new를 사용하도록 강제할 수 있다.
```
function createObject() {
  if (!(this instanceof createObject)) {
    throw new Error("이 객체는 new를 사용하여 생성해야 합니다.");
  }
}
```

## new.target
이 내용은 [모던 자바스크립트](https://ko.javascript.info/constructor-new#ref-822)에서 참고 했다.

new.target 프로퍼티를 사용하면 함수가 new와 함께 호출되었는지 아닌지 알 수 있다.
new 키워드 없이 호출했다면 `undefined`, new와 함께 호출한 경우엔 `함수 자체`를 반환해준다.
```
function createObject() {
  if (!new.target) {
    throw new Error("이 객체는 new를 사용하여 생성해야 합니다.");
  }
} 
```

이 외에 new가 없을 때 에러를 뱉지 않고 자동으로 new를 붙여 인스턴스를 만들어 반환하게 하는 방법도 있지만, 일관성 있는 코드베이스 구축에 장애물이 될 수 있기 때문에 위의 instanceof 보호장치가 더 낫다.

## 함수 구현부 공유
생성자 함수의 프로토타입에 함수를 정의하면 모든 인스턴스가 함수 사본 하나를 공유하기 때문에 객체 인스턴스를 대량 생성할 때 메모리 점유율과 성능을 모두 잡을 수 있는 이점이 있다.

# 클래스 상속
원래 자바스크립트에는 클래스가 없어서 프로토타입 상속을 이용해 클래스 상속을 흉내냈었는데, ES6에서부터 class 키워드가 등장했다. 그러나 내부적으로는 결국 생성자 함수와 프로토타입을 이용하여 구현한 것이기 때문에 실질적인 클래스라기 보다는 문법 설탕에 가깝다고 하는 사람도 많다.

## 고전적 상속 흉내 내기

```
// 상속할 생성자 함수
function Animal(arg) {
  // ...
}
// 상속받을 생성자 함수
function Kangaroo(arg) {
  // ...
}
Kangaroo.prototype = new Animal();
Kangaroo.protorype.hop = function() {
  return `${this.name}가 껑충 뛰었어요.`;
}
```
위와 같이 Kangaroo 함수의 기본 프로토타입을 Animal 인스턴스로 교체하고, 확장하려는 함수를 추가하여 확장하면 Animal 함수를 변경하지 않고 상속과 확장이 가능하다.

## 반복을 피할 수 없다.
위와 같이 고전적 상속을 흉내 내면 코드 반복과 메모리 점유를 피하기 어렵다. 프로토타입 지정 시 인자를 알 수 없기 때문에 Animal 함수에서 정의한 프로퍼티 할당 작업을 Kangaroo 에서 그대로 반복할 수 밖에 없다. 이것은 DRY 원칙 위반이다.  
또한 Kangaroo 인스턴스는 자기 자신의 프로퍼티와 Animal에 있는 프로퍼티까지 모두 가지고 있는 꼴이기 때문에 비효율적이다.

# 함수형 상속
함수형 상속은 클래스 상속의 생성자 반복 문제를 해결하면서, 외부 객체 사용부와 상속자로부터 데이터를 감추는 것이 가능하다. 앞서 언급한 모듈 패턴을 이용한다.

```
AnimalKindom.Animal = function(name, type) {
  const instanceName = name;
  const instanceType = type;

  return {
    getName: function() {
      return instanceName;
    },
    getType: function() {
      return instanceType;
    }
  }
}
AnimalKindom.kangaroo = function(name) {
  const base = AnimalKindom.Animal(name, 'kangaroo');

  base.hop = function() {
    return `${base.getName()}가 껑충 뛰었어요.`;
  };
  return base;
}
```
이렇게 하면 코드를 반복하지 않고 AnimalKindom.Animal 함수를 변경하지 않으면서도 같은 프로퍼티를 가진 객체에 함수 확장까지 가능하다.
함수형 상속은 SOLID/DRY 원칙을 잘 따르는 패턴이다.

# 멍키 패칭
멍키 패칭은 추가 프로퍼티를 객체에 붙이는 것으로 한 객체의 기능 다발 전체를 다른 객체로 패치할 수 있다.  
이 패턴은 **메서드 빌림**이라는 타이틀로 19장에서 다시 설명할 예정이니 여기서는 넘어간다.  
사실 내가 아직 깊이 이해하지 못했다 ㅠ_ㅠ

# 정리하기
객체를 생성하는 방법을 SOLID/DRY 기준에 비추어 알아보았다.  
원시형과 객체 리터럴은 사용하기 쉽지만, 코드 중복이 일어나기 쉽다.  
모듈 패턴은 이와 관련된 가장 확실한 개선책이다. 데이터 캡슐화와 애스팩트 지향 프로그래밍이 가능하여 확장과 단위 테스트를 매끄럽게 한다.  
생성자 함수 패턴은 사용 여부에 대한 의견이 분분하지만, 초기화 코드 공유가 가능하고 new를 강제하는 것이 그리 어렵지 않기 때문에 나쁘지 않다.  
또한 모든 함수는 prototype 프로퍼티를 통해 인스턴스 간에 데이터를 공유하는 상속 매커니즘이 가능하다. 이를 구현할 때는 코드 반복을 없애고 데이터를 감출 수 있는 함수형 상속을 추천한다.  
마지막으로 멍키 패칭을 잘 활용하면 한 객체의 기능을 다른 객체로 기증할 수 있다.

사실 개인적으로 모든 패턴이 장단점이 있어서 상황에 따라 적절하게 골라서 사용할 수 있다고 생각이 드는데, 해당 책에서는 SOLID 기준으로 설명하기 때문에 실무를 생각해보면 너무 기준이 깐깐하다고(?) 느껴진다. 특히 아직도 리스코프 치환 개념은 이해하기가 어렵다;;  
그치만 함수형 상속이 가장 깔끔하고 모든 기준에 충족하면서도 이해하기가 쉬워서 가장 추천하는 패턴이라는데는 격하게 동의한다.
